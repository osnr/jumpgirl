// Generated by CoffeeScript 1.4.0
(function() {
  var ENEMY_MAP, GRAVITY, SCREEN_COLS, SCREEN_ROWS, TILE_HEIGHT, TILE_MAP, TILE_MAP_COLS, TILE_MAP_ROWS, TILE_WIDTH, animFor, animMap, checkEnemyCollisions, checkXCollisions, checkYCollisions, draw, drawBackground, drawDebugInfo, drawDude, drawEnemies, drawGameOver, drawMapAboveHero, drawMapBelowHero, drawTile, dudeImages, dudeIntersectsDude, dudeIntersectsTile, enemies, gameOver, hero, hitPowerup, keyJump, keyLeft, keyPressed, keyReleased, keyRight, killHero, loadEnemies, loadEnemy, maxHeroSpeed, powerImages, rectIntersectsRect, rectIntersectsTile, scroll, scrollX, scrollY, t, tGameOver, tileAdj, tileAdjIsBlocking, tileCoordsAdj, tileCoordsForPoint, tileFor, tileForPoint, tileImages, tileIsBlocking, tileIsPowerup, timer, update, updateEnemies, updateHero, updateHeroXVelocity, updateHeroYVelocity, woundHero;

  drawBackground = function() {
    return background(216, 245, 252);
  };

  TILE_HEIGHT = 43;

  TILE_WIDTH = 100;

  SCREEN_ROWS = 7;

  SCREEN_COLS = 4;

  TILE_MAP = [[0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]];

  TILE_MAP_ROWS = TILE_MAP.length;

  TILE_MAP_COLS = TILE_MAP[0].length;

  ENEMY_MAP = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];

  GRAVITY = 2;

  tileFor = function(tX, tY) {
    if (typeof tX === "object") {
      tY = tX[1];
      tX = tX[0];
    }
    if (tY < TILE_MAP_ROWS && tX < TILE_MAP_COLS && tY >= 0 && tX >= 0) {
      return TILE_MAP[tY][tX];
    } else if (tY < 0) {
      return 0;
    } else {
      return -1;
    }
  };

  tileCoordsForPoint = function(x, y) {
    if (typeof x === "object") {
      y = x[1];
      x = x[0];
    }
    return [floor(x / TILE_WIDTH), floor(y / TILE_HEIGHT)];
  };

  tileForPoint = function(x, y) {
    var tX, tY, tileCoords;
    tileCoords = tileCoordsForPoint(x, y);
    tX = tileCoords[0];
    tY = tileCoords[1];
    return tileFor(tX, tY);
  };

  rectIntersectsRect = function(x1, y1, w1, h1, x2, y2, w2, h2) {
    return (((x1 <= x2) && (x2 <= x1 + w1)) || ((x2 <= x1) && (x1 <= x2 + w2))) && (((y1 <= y2) && (y2 <= y1 + h1)) || ((y2 <= y1) && (y1 <= y2 + h2)));
  };

  rectIntersectsTile = function(x, y, w, h, tX, tY) {
    return rectIntersectsRect(x, y, w, h, tX * TILE_WIDTH, tY * TILE_HEIGHT, tX * TILE_WIDTH + TILE_WIDTH, tY * TILE_HEIGHT + TILE_HEIGHT);
  };

  dudeIntersectsTile = function(dude, tX, tY) {
    return rectIntersectsTile(dude.x + dude.cXOffset, dude.y + dude.cYOffset, dude.cWidth, dude.cHeight, tX, tY);
  };

  dudeIntersectsDude = function(dude1, dude2) {
    return rectIntersectsRect(dude1.x + dude1.cXOffset, dude1.y + dude1.cYOffset, dude1.cWidth, dude1.cHeight, dude2.x + dude2.cXOffset, dude2.y + dude2.cYOffset, dude2.cWidth, dude2.cHeight);
  };

  t = 0;

  gameOver = false;

  scrollX = 0;

  scrollY = 0;

  animMap = {};

  tileImages = {
    1: getImage("cute/DirtBlock"),
    2: getImage("cute/WoodBlock"),
    3: getImage("cute/PlainBlock"),
    4: getImage("cute/ChestOpen")
  };

  animFor = function(tX, tY) {
    var anim;
    if (tY in animMap && tX in animMap[tY]) {
      anim = animMap[tY][tX];
      if (anim.type === "powerup") {
        anim.yOffset = anim.t * anim.t - 6 * anim.t;
        if (anim.t > 0 && anim.yOffset === 0) {
          delete animMap[tY][tX];
        }
      }
      anim.t += 1;
      return anim;
    }
  };

  drawTile = function(tX, tY) {
    var anim, tileImage;
    anim = animFor(tX, tY);
    if (anim) {
      return image(tileImages[anim.tile], TILE_WIDTH * tX + scrollX + anim.xOffset, TILE_HEIGHT * tY + scrollY + anim.yOffset);
    } else {
      tileImage = tileImages[tileFor(tX, tY)];
      if (!tileImage) {
        return;
      }
      return image(tileImages[tileFor(tX, tY)], TILE_WIDTH * tX + scrollX, TILE_HEIGHT * tY + scrollY);
    }
  };

  dudeImages = {
    1: getImage("cute/CharacterHornGirl"),
    2: getImage("cute/EnemyBug")
  };

  powerImages = {
    armed: getImage("avatars/leaf-blue")
  };

  hero = {
    x: 0,
    y: 0,
    xVelocity: 0,
    yVelocity: 0,
    wounded: false,
    lastWounded: 0,
    cXOffset: 20,
    cWidth: TILE_WIDTH - 40,
    cYOffset: 0,
    cHeight: TILE_HEIGHT,
    im: 1,
    jump: 0,
    running: false,
    facesLeft: false,
    ySway: 0,
    power: "none",
    dead: false,
    rotation: 0
  };

  hitPowerup = function(tX, tY) {
    if (!(tY in animMap)) {
      animMap[tY] = {};
    }
    animMap[tY][tX] = {
      tile: tileFor(tX, tY),
      type: "powerup",
      xOffset: 0,
      yOffset: 0,
      t: 0
    };
    if (hero.power === "none") {
      return hero.power = "armed";
    }
  };

  drawDude = function(dude) {
    var dying, img, mod, x, y;
    mod = void 0;
    if (dude.wounded && !dude.dead && round(t / 3) % 2 === 0) {
      return;
    }
    if (dude.xVelocity !== 0) {
      if (dude.xVelocity < 0) {
        dude.facesLeft = true;
      } else {
        if (dude.xVelocity > 0) {
          dude.facesLeft = false;
        }
      }
      if (dude.yVelocity === 0) {
        if (dude.ySway === 0) {
          dude.ySway = 1;
        } else {
          if (dude.running) {
            mod = 3;
          } else {
            mod = 4;
          }
          if ((t % mod) === 0) {
            dude.ySway = -dude.ySway;
          }
        }
      }
    } else {
      dude.ySway = 0;
    }
    img = dudeImages[dude.im];
    x = dude.x + scrollX;
    y = dude.y + scrollY + dude.ySway;
    dying = dude.dead && (dude.y + scrollY) < height;
    if (dying) {
      pushMatrix();
      if (dude.yVelocity <= 0) {
        dude.rotation += 100 * sin(10 * frameCount);
      }
      translate(x + img.width / 2, y + img.height / 2);
      rotate(dude.rotation);
      translate(-x - img.width / 2, -y - img.height / 2);
    }
    if (dude.facesLeft) {
      pushMatrix();
      scale(-1, 1);
      image(img, -x - img.width, y);
      popMatrix();
    } else {
      image(img, x, y);
    }
    if (dude.power && dude.power !== "none") {
      image(powerImages[dude.power], dude.x + scrollX, dude.y + scrollY + dude.ySway);
    }
    if (dying) {
      return popMatrix();
    }
  };

  enemies = [];

  loadEnemy = function(id, tX, tY) {
    var im;
    im = void 0;
    if (id === 0) {
      return;
    }
    return enemies.push({
      x: tX * TILE_WIDTH,
      y: tY * TILE_HEIGHT,
      xVelocity: 0,
      yVelocity: 0,
      wounded: false,
      im: id,
      ySway: 0,
      cXOffset: 0,
      cWidth: TILE_WIDTH,
      cYOffset: 0,
      cHeight: TILE_HEIGHT
    });
  };

  loadEnemies = function() {
    var tX, tY, _results;
    tY = 0;
    _results = [];
    while (tY < TILE_MAP_ROWS) {
      tX = 0;
      while (tX < TILE_MAP_COLS) {
        if (ENEMY_MAP[tY][tX] !== 0) {
          loadEnemy(ENEMY_MAP[tY][tX], tX, tY);
        }
        tX += 1;
      }
      _results.push(tY += 1);
    }
    return _results;
  };

  loadEnemies();

  drawEnemies = function() {
    var i, _results;
    i = 0;
    _results = [];
    while (i < enemies.length) {
      drawDude(enemies[i]);
      _results.push(i += 1);
    }
    return _results;
  };

  drawMapBelowHero = function() {
    var heroRow, tX, tY, _results;
    heroRow = max(floor(hero.y / TILE_HEIGHT), 0);
    tY = TILE_MAP_ROWS - 1;
    _results = [];
    while (tY >= heroRow) {
      tX = 0;
      while (tX < TILE_MAP_COLS) {
        drawTile(tX, tY);
        tX += 1;
      }
      _results.push(tY -= 1);
    }
    return _results;
  };

  drawMapAboveHero = function() {
    var heroRow, tX, tY, _results;
    heroRow = floor(hero.y / TILE_HEIGHT);
    if (heroRow >= 0) {
      tY = heroRow;
      _results = [];
      while (tY >= 0) {
        tX = 0;
        while (tX < TILE_MAP_COLS) {
          drawTile(tX, tY);
          tX += 1;
        }
        _results.push(tY -= 1);
      }
      return _results;
    }
  };

  tileCoordsAdj = function(dude, dir, amt) {
    var x, y;
    x = void 0;
    y = void 0;
    amt = amt || 1;
    if (dir === "left") {
      x = dude.x + dude.cXOffset - amt;
      y = dude.y + dude.cYOffset;
    } else if (dir === "right") {
      x = dude.x + dude.cXOffset + dude.cWidth + amt;
      y = dude.y + dude.cYOffset;
    } else if (dir === "below left") {
      x = dude.x + dude.cXOffset;
      y = dude.y + dude.cYOffset + dude.cHeight + amt;
    } else if (dir === "below right") {
      x = dude.x + dude.cXOffset + dude.cWidth;
      y = dude.y + dude.cYOffset + dude.cHeight + amt;
    } else if (dir === "above left") {
      x = dude.x + dude.cXOffset;
      y = dude.y + dude.cYOffset - amt;
    } else if (dir === "above right") {
      x = dude.x + dude.cXOffset + dude.cWidth;
      y = dude.y + dude.cYOffset - amt;
    }
    return tileCoordsForPoint(x, y);
  };

  tileAdj = function(dude, dir, amt) {
    return tileFor(tileCoordsAdj(dude, dir, amt));
  };

  tileIsBlocking = function(tile) {
    return tile !== 0;
  };

  tileIsPowerup = function(tile) {
    return tile === 3;
  };

  tileAdjIsBlocking = function(dude, dir, amt) {
    if (dir === "left" || dir === "right") {
      return tileIsBlocking(tileAdj(dude, dir, amt));
    } else {
      if (dir === "below" || dir === "above") {
        return tileIsBlocking(tileAdj(dude, dir + " left", amt)) || tileIsBlocking(tileAdj(dude, dir + " right", amt));
      }
    }
  };

  checkXCollisions = function(dude) {
    var _results, _results1;
    if (tileAdjIsBlocking(dude, "left") && dude.xVelocity < 0) {
      dude.xVelocity = 0;
      _results = [];
      while (tileAdjIsBlocking(dude, "left") && !tileAdjIsBlocking(dude, "right")) {
        _results.push(dude.x += 1);
      }
      return _results;
    } else if (tileAdjIsBlocking(dude, "right") && dude.xVelocity > 0) {
      dude.xVelocity = 0;
      _results1 = [];
      while (tileAdjIsBlocking(dude, "right") && !tileAdjIsBlocking(dude, "left")) {
        _results1.push(dude.x -= 1);
      }
      return _results1;
    }
  };

  checkYCollisions = function(dude) {
    var curTile, tal, tar, _results, _results1;
    tal = void 0;
    tar = void 0;
    curTile = tileCoordsForPoint(dude.x, dude.y);
    if (tileAdjIsBlocking(dude, "below") && dude.yVelocity > 0) {
      dude.yVelocity = 0;
      _results = [];
      while (tileAdjIsBlocking(dude, "below")) {
        _results.push(dude.y -= 1);
      }
      return _results;
    } else if (tileAdjIsBlocking(dude, "above") && dude.yVelocity < 0) {
      dude.yVelocity = dude.yVelocity * -1 / 2;
      tal = tileCoordsAdj(dude, "above left");
      if (tileIsPowerup(tileFor(tal))) {
        hitPowerup(tal[0], tal[1]);
      } else {
        tar = tileCoordsAdj(dude, "above right");
        if (tileIsPowerup(tileFor(tal))) {
          hitPowerup(tar[0], tar[1]);
        }
      }
      _results1 = [];
      while (tileAdjIsBlocking(dude, "above")) {
        _results1.push(dude.y += 1);
      }
      return _results1;
    }
  };

  keyJump = false;

  keyLeft = false;

  keyRight = false;

  keyPressed = function() {
    if (keyCode === 32) {
      return keyJump = true;
    } else if (keyCode === SHIFT) {
      return hero.running = true;
    } else if (keyCode === LEFT) {
      return keyLeft = true;
    } else {
      if (keyCode === RIGHT) {
        return keyRight = true;
      }
    }
  };

  keyReleased = function() {
    if (keyCode === 32) {
      return keyJump = false;
    } else if (keyCode === SHIFT) {
      return hero.running = false;
    } else if (keyCode === LEFT) {
      return keyLeft = false;
    } else {
      if (keyCode === RIGHT) {
        return keyRight = false;
      }
    }
  };

  maxHeroSpeed = function() {
    if (hero.running) {
      return 15;
    } else {
      return 9;
    }
  };

  updateHeroXVelocity = function() {
    if (keyRight) {
      if (hero.xVelocity < 0) {
        hero.xVelocity = 0;
      }
      hero.xVelocity += 1;
    } else if (keyLeft) {
      if (hero.xVelocity > 0) {
        hero.xVelocity = 0;
      }
      hero.xVelocity -= 1;
    } else {
      if (hero.xVelocity > 0) {
        hero.xVelocity -= 0.5;
      } else {
        if (hero.xVelocity < 0) {
          hero.xVelocity += 0.5;
        }
      }
    }
    if (hero.xVelocity > maxHeroSpeed()) {
      return hero.xVelocity = 9;
    } else {
      if (hero.xVelocity < -maxHeroSpeed()) {
        return hero.xVelocity = -9;
      }
    }
  };

  updateHeroYVelocity = function() {
    if (keyJump) {
      if (hero.yVelocity === 0 && tileAdjIsBlocking(hero, "below", 2)) {
        hero.jump = 1;
      }
      if (hero.jump > 0 && hero.jump < 10) {
        hero.jump += 1;
        hero.yVelocity -= 6;
      }
    }
    if (!keyJump || hero.jump >= 10) {
      hero.jump = 0;
    }
    if (hero.yVelocity < -18) {
      return hero.yVelocity = -18;
    } else {
      if (hero.yVelocity > 30) {
        return hero.yVelocity = 30;
      }
    }
  };

  killHero = function() {
    hero.yVelocity -= 100;
    return hero.dead = true;
  };

  woundHero = function() {
    hero.wounded = true;
    hero.lastWounded = t;
    if (hero.power !== "none") {
      return hero.power = "none";
    } else {
      return killHero();
    }
  };

  checkEnemyCollisions = function() {
    var i, _results;
    if (hero.wounded) {
      return;
    }
    i = 0;
    _results = [];
    while (i < enemies.length) {
      if (dudeIntersectsDude(hero, enemies[i])) {
        if (hero.yVelocity > 0) {
          hero.yVelocity -= 30;
          enemies.splice(i, 1);
        } else {
          woundHero();
        }
      }
      _results.push(i += 1);
    }
    return _results;
  };

  updateHero = function() {
    updateHeroXVelocity();
    updateHeroYVelocity();
    hero.yVelocity += GRAVITY;
    hero.x += hero.xVelocity;
    hero.y += hero.yVelocity;
    if (hero.dead) {
      if (hero.y + scrollY + dudeImages[hero.im].height > height) {
        return gameOver = true;
      }
    } else {
      checkXCollisions(hero);
      checkYCollisions(hero);
      return checkEnemyCollisions();
    }
  };

  scroll = function() {
    if ((hero.x + scrollX > width / 2 && hero.xVelocity > 0) || (hero.x + scrollX < width / 2 && hero.xVelocity < 0)) {
      scrollX -= floor(hero.xVelocity);
    }
    return (hero.y + scrollY > height / 2 && hero.yVelocity > 0) || (hero.y + scrollY < height / 2 && hero.yVelocity < 0);
  };

  updateEnemies = function() {
    var enemy, i, _results;
    enemy = void 0;
    i = 0;
    _results = [];
    while (i < enemies.length) {
      enemy = enemies[i];
      enemy.yVelocity += GRAVITY;
      enemy.x += enemy.xVelocity;
      enemy.y += enemy.yVelocity;
      checkXCollisions(enemy);
      checkYCollisions(enemy);
      _results.push(i += 1);
    }
    return _results;
  };

  update = function() {
    updateHero();
    updateEnemies();
    return scroll();
  };

  drawDebugInfo = function(scaleFactor) {
    var i, tX, tY;
    noStroke();
    fill(255, 255, 255);
    rect(0, 0, TILE_MAP_COLS * TILE_WIDTH * scaleFactor, TILE_MAP_ROWS * TILE_HEIGHT * scaleFactor);
    tY = 0;
    while (tY < TILE_MAP_ROWS) {
      tX = 0;
      while (tX < TILE_MAP_COLS) {
        if (tileFor(tX, tY) !== 0) {
          fill(0, 0, 0);
          rect(tX * TILE_WIDTH * scaleFactor, tY * TILE_HEIGHT * scaleFactor, TILE_WIDTH * scaleFactor, TILE_HEIGHT * scaleFactor);
        }
        tX += 1;
      }
      tY += 1;
    }
    fill(0, 0, 255);
    rect(hero.x * scaleFactor, hero.y * scaleFactor, TILE_WIDTH * scaleFactor, TILE_HEIGHT * scaleFactor);
    fill(255, 0, 0);
    i = 0;
    while (i < enemies.length) {
      rect(enemies[i].x * scaleFactor, enemies[i].y * scaleFactor, TILE_WIDTH * scaleFactor, TILE_HEIGHT * scaleFactor);
      i += 1;
    }
    noFill();
    stroke(0, 0, 255);
    return rect(-scrollX * scaleFactor, -scrollY * scaleFactor, SCREEN_COLS * TILE_WIDTH * scaleFactor, SCREEN_ROWS * TILE_HEIGHT * scaleFactor);
  };

  timer = function() {
    if (hero.wounded && t - hero.lastWounded > 60) {
      hero.wounded = false;
    }
    return t += 1;
  };

  tGameOver = 0;

  drawGameOver = function() {
    if (tGameOver === 255) {
      fill(255, 0, 0);
      text("GAME OVER", width / 2, height / 2);
    } else {
      fill(0, 0, 0, tGameOver);
      rect(0, 0, width, height);
    }
    return tGameOver += 1;
  };

  draw = function() {
    update();
    drawBackground();
    drawMapBelowHero();
    drawEnemies();
    drawDude(hero);
    drawMapAboveHero();
    drawDebugInfo(1 / 10);
    if (gameOver) {
      drawGameOver();
    }
    return timer();
  };

}).call(this);
